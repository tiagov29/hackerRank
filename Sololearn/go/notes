package main : is the core of go everything begin in this function
fmt :
-for print something in the console => fmt.Println()
-for reading an input => fmt.Scanln(&variable)

varibale:
 var nameOfVariable int
 const nameOfVariable int

function:
allow to define a block of code

func sum(x,y int) int {
	return x+y
}
//the int outside of the brackets is for define the type of the return

func welcome(){
	fmt.println("Welcome")
}
func main(){
	defer welcome()
	fmt.Println("hey")
}
// with defer we guarantew the function run in the last turn

func calc(x int) ( int , int) {
	return (x*2, x*X)
}
//function take one input and return two integers double and his square

POINTERS
// pointers are special variables that hold the memory address of values.
// we declare it using *

var p *int //p is a ponter to an integer value.

// Using & operator, returns the memory address of a variable.
x := 42
p := &x // p is a pointer and holds the memory address of x.

// if we want to access to the underlying value of a pointer, we can use the *
fm.Println(*p) // returns 42
// we can change the value of the memory address the pointer holds:
*p = 8
fmt.println(*p) //returns 8

STRUCTS
//Structs are collections of fields that allow you to group data together.

type Contact struct {
	name string
	age int
}

// our Contact struct has two fields, a string and an integer.

x := Contact{"Santi", 30} // for creating a new contact

p := &x // here we can referenciate a struct

fmt.println(p.age) // returns 30

p := &Contact{"john",15} // we can use a pointer when we are creating a new struct

//methods are symple functions with a special receiver argument. Let's have a look at an
//example:

func (x Contact) welcome(){
	fmt.println(x.name)
	fmt.println(x.age)
}
// the receiver is the x XContact

x.welcome() // for calling the method

// code example

func welcome( x Contact) {
	fmt.Println(x.name)
	fmt.Println(x.age)
}
func main() {
	x := Contact{"James", 42}
	welcome(x)
}

// for change the data of the struct in a method, we can use pointers as method recivers

func (ptr *Contact) increase(val int){
	ptr.age += val
}

x := Contact{"james", 42}
x.increase(8)
fmt.Println(x.age)

ARRAYS
//We define an array using square brackets which define the number of elements
// the array will hold.
var a [5]int

a := [5]int{0, 2, 4, 6, 8} //you can define and initialize values of the array


var a [5]int

a[0] = 8
a[1] = 42

fmt.Println(a[1]) // returns 42

// An array has a FIXED size, meaning once defined, you cannot change the number
//of elements it holds for that reason go provides the slice, which is a dynamically-sized
// view into the elements of an array.
a := [5]int{0, 2, 4, 6, 8}
var s []int = a[1:3]
//this code selects the elements with index 1 to 3 from the a array, including
//the first given index, but excluding the last.
// So, the slice s will now include the values[2,4]
fmt.Println(s) // returns [0,6,8]
// you can access the values of the slice the same syntax as with arrays.

a := [5]int{0, 2, 4, 6, 8}
var s []int = a[1:3]

fmt.Println(s[1])
//A slice doesnÂ´t store any data; it just describe a section of an underlying
// array. Changing the elements  of a slice modifies the corresponding elements
//of its underlying array
s[0] = 8
fmt.Println(a)

// go provides a make() function to create slices. This is how you create
// dynamically-sized arrays.

a := make([]int, 5)
// the make function creates an array of the given type and size, and returns
// a slice that refers to that array.
// after creating a slice, we can add append new elements to it using the append()
// function.

a := make([]int, 5)
a = append(a,8)
fmt.Println(a)

RANGE
// the range form of the for loop allows you to iterate
// over a slice:
a := make([]int, 5)
a[1] = 2
a[2] = 3

for i, v := range a {
	fmt.Println(i, v)
}